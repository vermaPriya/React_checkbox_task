{"ast":null,"code":"import './getDocument.js';\nimport { matches } from './matches.js';\nimport { closest } from './closest.js';\nimport { getActiveElement } from './getActiveElement.js';\n/** @module tabbable */\n\nvar selector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" + \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" + \"iframe, object, embed, area[href], audio[controls], video[controls], \" + \"[contenteditable]:not([contenteditable='false'])\";\n\nfunction isVisible(element) {\n  var htmlElement = element;\n  return htmlElement.offsetWidth > 0 || htmlElement.offsetHeight > 0 || element.getClientRects().length > 0;\n}\n\nfunction hasNegativeTabIndex(element) {\n  var tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10);\n  return tabIndex < 0;\n}\n/**\n * Checks whether `element` is focusable or not.\n *\n * @memberof tabbable\n *\n * @example\n * import { isFocusable } from \"reakit-utils\";\n *\n * isFocusable(document.querySelector(\"input\")); // true\n * isFocusable(document.querySelector(\"input[tabindex='-1']\")); // true\n * isFocusable(document.querySelector(\"input[hidden]\")); // false\n * isFocusable(document.querySelector(\"input:disabled\")); // false\n */\n\n\nfunction isFocusable(element) {\n  return matches(element, selector) && isVisible(element);\n}\n/**\n * Checks whether `element` is tabbable or not.\n *\n * @memberof tabbable\n *\n * @example\n * import { isTabbable } from \"reakit-utils\";\n *\n * isTabbable(document.querySelector(\"input\")); // true\n * isTabbable(document.querySelector(\"input[tabindex='-1']\")); // false\n * isTabbable(document.querySelector(\"input[hidden]\")); // false\n * isTabbable(document.querySelector(\"input:disabled\")); // false\n */\n\n\nfunction isTabbable(element) {\n  return isFocusable(element) && !hasNegativeTabIndex(element);\n}\n/**\n * Returns all the focusable elements in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n *\n * @returns {Element[]}\n */\n\n\nfunction getAllFocusableIn(container) {\n  var allFocusable = Array.from(container.querySelectorAll(selector));\n  allFocusable.unshift(container);\n  return allFocusable.filter(isFocusable);\n}\n/**\n * Returns the first focusable element in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n *\n * @returns {Element|null}\n */\n\n\nfunction getFirstFocusableIn(container) {\n  var _getAllFocusableIn = getAllFocusableIn(container),\n      first = _getAllFocusableIn[0];\n\n  return first || null;\n}\n/**\n * Returns all the tabbable elements in `container`, including the container\n * itself.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return focusable elements if there are no tabbable ones.\n *\n * @returns {Element[]}\n */\n\n\nfunction getAllTabbableIn(container, fallbackToFocusable) {\n  var allFocusable = Array.from(container.querySelectorAll(selector));\n  var allTabbable = allFocusable.filter(isTabbable);\n\n  if (isTabbable(container)) {\n    allTabbable.unshift(container);\n  }\n\n  if (!allTabbable.length && fallbackToFocusable) {\n    return allFocusable;\n  }\n\n  return allTabbable;\n}\n/**\n * Returns the first tabbable element in `container`, including the container\n * itself if it's tabbable.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the first focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\n\nfunction getFirstTabbableIn(container, fallbackToFocusable) {\n  var _getAllTabbableIn = getAllTabbableIn(container, fallbackToFocusable),\n      first = _getAllTabbableIn[0];\n\n  return first || null;\n}\n/**\n * Returns the last tabbable element in `container`, including the container\n * itself if it's tabbable.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the last focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\n\nfunction getLastTabbableIn(container, fallbackToFocusable) {\n  var allTabbable = getAllTabbableIn(container, fallbackToFocusable);\n  return allTabbable[allTabbable.length - 1] || null;\n}\n/**\n * Returns the next tabbable element in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the next focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\n\nfunction getNextTabbableIn(container, fallbackToFocusable) {\n  var activeElement = getActiveElement(container);\n  var allFocusable = getAllFocusableIn(container);\n  var index = allFocusable.indexOf(activeElement);\n  var slice = allFocusable.slice(index + 1);\n  return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);\n}\n/**\n * Returns the previous tabbable element in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the previous focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\n\nfunction getPreviousTabbableIn(container, fallbackToFocusable) {\n  var activeElement = getActiveElement(container);\n  var allFocusable = getAllFocusableIn(container).reverse();\n  var index = allFocusable.indexOf(activeElement);\n  var slice = allFocusable.slice(index + 1);\n  return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);\n}\n/**\n * Returns the closest focusable element.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n *\n * @returns {Element|null}\n */\n\n\nfunction getClosestFocusable(element) {\n  while (element && !isFocusable(element)) {\n    element = closest(element, selector);\n  }\n\n  return element;\n}\n\nexport { getAllFocusableIn, getAllTabbableIn, getClosestFocusable, getFirstFocusableIn, getFirstTabbableIn, getLastTabbableIn, getNextTabbableIn, getPreviousTabbableIn, isFocusable, isTabbable };","map":{"version":3,"sources":["/home/priya/Desktop/reactCheckBoxTask/node_modules/reakit-utils/es/tabbable.js"],"names":["matches","closest","getActiveElement","selector","isVisible","element","htmlElement","offsetWidth","offsetHeight","getClientRects","length","hasNegativeTabIndex","tabIndex","parseInt","getAttribute","isFocusable","isTabbable","getAllFocusableIn","container","allFocusable","Array","from","querySelectorAll","unshift","filter","getFirstFocusableIn","_getAllFocusableIn","first","getAllTabbableIn","fallbackToFocusable","allTabbable","getFirstTabbableIn","_getAllTabbableIn","getLastTabbableIn","getNextTabbableIn","activeElement","index","indexOf","slice","find","getPreviousTabbableIn","reverse","getClosestFocusable"],"mappings":"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","sourcesContent":["import './getDocument.js';\nimport { matches } from './matches.js';\nimport { closest } from './closest.js';\nimport { getActiveElement } from './getActiveElement.js';\n\n/** @module tabbable */\nvar selector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" + \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" + \"iframe, object, embed, area[href], audio[controls], video[controls], \" + \"[contenteditable]:not([contenteditable='false'])\";\n\nfunction isVisible(element) {\n  var htmlElement = element;\n  return htmlElement.offsetWidth > 0 || htmlElement.offsetHeight > 0 || element.getClientRects().length > 0;\n}\n\nfunction hasNegativeTabIndex(element) {\n  var tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10);\n  return tabIndex < 0;\n}\n/**\n * Checks whether `element` is focusable or not.\n *\n * @memberof tabbable\n *\n * @example\n * import { isFocusable } from \"reakit-utils\";\n *\n * isFocusable(document.querySelector(\"input\")); // true\n * isFocusable(document.querySelector(\"input[tabindex='-1']\")); // true\n * isFocusable(document.querySelector(\"input[hidden]\")); // false\n * isFocusable(document.querySelector(\"input:disabled\")); // false\n */\n\n\nfunction isFocusable(element) {\n  return matches(element, selector) && isVisible(element);\n}\n/**\n * Checks whether `element` is tabbable or not.\n *\n * @memberof tabbable\n *\n * @example\n * import { isTabbable } from \"reakit-utils\";\n *\n * isTabbable(document.querySelector(\"input\")); // true\n * isTabbable(document.querySelector(\"input[tabindex='-1']\")); // false\n * isTabbable(document.querySelector(\"input[hidden]\")); // false\n * isTabbable(document.querySelector(\"input:disabled\")); // false\n */\n\nfunction isTabbable(element) {\n  return isFocusable(element) && !hasNegativeTabIndex(element);\n}\n/**\n * Returns all the focusable elements in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n *\n * @returns {Element[]}\n */\n\nfunction getAllFocusableIn(container) {\n  var allFocusable = Array.from(container.querySelectorAll(selector));\n  allFocusable.unshift(container);\n  return allFocusable.filter(isFocusable);\n}\n/**\n * Returns the first focusable element in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n *\n * @returns {Element|null}\n */\n\nfunction getFirstFocusableIn(container) {\n  var _getAllFocusableIn = getAllFocusableIn(container),\n      first = _getAllFocusableIn[0];\n\n  return first || null;\n}\n/**\n * Returns all the tabbable elements in `container`, including the container\n * itself.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return focusable elements if there are no tabbable ones.\n *\n * @returns {Element[]}\n */\n\nfunction getAllTabbableIn(container, fallbackToFocusable) {\n  var allFocusable = Array.from(container.querySelectorAll(selector));\n  var allTabbable = allFocusable.filter(isTabbable);\n\n  if (isTabbable(container)) {\n    allTabbable.unshift(container);\n  }\n\n  if (!allTabbable.length && fallbackToFocusable) {\n    return allFocusable;\n  }\n\n  return allTabbable;\n}\n/**\n * Returns the first tabbable element in `container`, including the container\n * itself if it's tabbable.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the first focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\nfunction getFirstTabbableIn(container, fallbackToFocusable) {\n  var _getAllTabbableIn = getAllTabbableIn(container, fallbackToFocusable),\n      first = _getAllTabbableIn[0];\n\n  return first || null;\n}\n/**\n * Returns the last tabbable element in `container`, including the container\n * itself if it's tabbable.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the last focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\nfunction getLastTabbableIn(container, fallbackToFocusable) {\n  var allTabbable = getAllTabbableIn(container, fallbackToFocusable);\n  return allTabbable[allTabbable.length - 1] || null;\n}\n/**\n * Returns the next tabbable element in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the next focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\nfunction getNextTabbableIn(container, fallbackToFocusable) {\n  var activeElement = getActiveElement(container);\n  var allFocusable = getAllFocusableIn(container);\n  var index = allFocusable.indexOf(activeElement);\n  var slice = allFocusable.slice(index + 1);\n  return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);\n}\n/**\n * Returns the previous tabbable element in `container`.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n * @param fallbackToFocusable If `true`, it'll return the previous focusable element if there are no tabbable ones.\n *\n * @returns {Element|null}\n */\n\nfunction getPreviousTabbableIn(container, fallbackToFocusable) {\n  var activeElement = getActiveElement(container);\n  var allFocusable = getAllFocusableIn(container).reverse();\n  var index = allFocusable.indexOf(activeElement);\n  var slice = allFocusable.slice(index + 1);\n  return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);\n}\n/**\n * Returns the closest focusable element.\n *\n * @memberof tabbable\n *\n * @param {Element} container\n *\n * @returns {Element|null}\n */\n\nfunction getClosestFocusable(element) {\n  while (element && !isFocusable(element)) {\n    element = closest(element, selector);\n  }\n\n  return element;\n}\n\nexport { getAllFocusableIn, getAllTabbableIn, getClosestFocusable, getFirstFocusableIn, getFirstTabbableIn, getLastTabbableIn, getNextTabbableIn, getPreviousTabbableIn, isFocusable, isTabbable };\n"]},"metadata":{},"sourceType":"module"}